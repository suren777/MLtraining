# -*- coding: utf-8 -*-
"""DeepScholes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HCAbO_xwERLcAiZ1iMBLo-1jgex0POmM
"""

import tensorflow.keras as k
from sklearn.model_selection import train_test_split
import numpy as np
import pickle
from scipy.stats import norm
from scipy.optimize import bisect

import matplotlib.pyplot as plt

def blackScholesPrice(F, K, T, vol):
    sqt = vol * np.sqrt(T)
    d1 = 1 / sqt * (np.log(F / K) + 0.5 * sqt ** 2)
    d2 = d1 - sqt
    n1 = norm.cdf(d1)
    n2 = norm.cdf(d2)
    return F * n1 - K * n2


def bsDelta(F, K, T, vol, sens=0.01):
    c1 = blackScholesPrice(F, K, T, vol)
    c2 = blackScholesPrice(F + sens, K, T, vol)
    return (c2 - c1) / sens


def bsVega(F, K, T, vol, sens=0.01):
    c1 = blackScholesPrice(F, K, T, vol)
    c2 = blackScholesPrice(F, K, T, vol)
    return (c1 - c2) / sens


def bsGamma(F, K, T, vol, sens=0.001):
    c1 = blackScholesPrice(F, K, T, vol)
    c2 = blackScholesPrice(F - sens, K, T, vol)
    c3 = blackScholesPrice(F + sens, K, T, vol)
    return (c3 - 2 * c1 + c2) / sens


def bsTheta(F, K, T, vol, sens=0.001):
    c1 = blackScholesPrice(F, K, T, vol)
    c2 = blackScholesPrice(F, K, T + sens, vol)
    return (c2 - c1) / sens


def impVol( F, K, T, C):
    def objFunc(vol):
        return C - blackScholesPrice(F, K, T, vol)

    vol = bisect(objFunc, 0.001, 2.0)
    return np.round(vol, 4)


vol = .5
C = blackScholesPrice(1.2, 1, 1, vol)
iVol = impVol( 1.2, 1, 1, C)
print("Input vol: {}".format(vol))
print("Opt Price : {}".format(C))
print("Implied vol: {}".format(iVol))

# Create a dataset
strikes = [x / 100. for x in range(50, 150, 5)]
tenors = [x / 10. for x in range(2, 50, 4)]
vols = [x / 100. for x in range(1, 100, 5)]
forwards = [x / 100. for x in range(50, 150, 5)]

inputs = np.array(np.meshgrid(forwards, strikes, tenors, vols)).T.reshape(-1, 4)


def mapHelper(a, ifVol = False):
    F, K, T, vol = a

    D = bsDelta(F, K, T, vol)
    G = bsGamma(F, K, T, vol)
    V = bsVega(F, K, T, vol)
    Th = bsTheta(F, K, T, vol)
    if not ifVol:
        C = blackScholesPrice(F, K, T, vol)
        return [C, D, G, V, Th]
    else:
        return [vol, D, G, V, Th]


try:
    with open('targets.pkl', 'rb') as f:
        targets = pickle.load(f)
except:
    targets = np.array(list(map(mapHelper, inputs)))
    with open('targets.pkl', 'wb') as f:
        pickle.dump(targets, f)

optionPrices = np.copy(targets[:, 0])
volLevels = np.copy(inputs[:, -1])

inputs[:, -1] = optionPrices
targets[:, 0] = volLevels

X_train, X_test, y_train, y_test = train_test_split(inputs, targets, test_size=0.2)

try:
    model = k.models.load_model('bs_model.h5')
    print("Model Found --- loading")
except:
    print("Model Not Found --- generating")
    hLayers = [5, 5, 5, 5, 5, 5, 5]
    model = k.models.Sequential()
    model.add(k.layers.Dense(units=hLayers[0], activation='relu', input_dim=4))
    for l in hLayers[1:]:
        model.add(k.layers.Dense(units=l, activation='linear'))

    model.add(k.layers.Dense(units=5, activation='relu'))
    model.compile(optimizer='RMSProp', loss='mse', metrics=['accuracy'])
    model.summary()

    model.fit(X_train, y_train, epochs=2000, batch_size=2048, validation_split=0.01, shuffle=True, verbose=2)
    model.save('bs_model.h5')
#model.evaluate(X_test, y_test)
if True:
    model.compile(optimizer='Adadelta', loss='mean_absolute_error', metrics=['acc', 'mae'])
    model.summary()
    model.fit(X_train, y_train, epochs=10000, batch_size=2048, validation_split=0.01, shuffle=True, verbose=2)
    model.save('bs_model.h5')
K = 1.
F = 1.2
T = 1.
vol = 0.5
# dataset = np.array([[F, K, T, blackScholesPrice(F, K, T, vol)] for vol in vols])
# actuals = np.array([mapHelper([F, K, T, vol], ifVol=True) for vol in vols])
model.evaluate(X_test, y_test)
dataset = np.array([[F, K, T, blackScholesPrice(F, K, T, vol)] for K in strikes])
actuals = np.array([mapHelper([F, K, T, vol], ifVol=True) for K in strikes])

predictions = model.predict(dataset)
optionPrices = dataset[:, -1]
labels = ['IV','Delta', 'Gamma', 'Vega', 'Theta']
for i in range(0, 5):
    plt.subplot(320+i+1)
    plt.plot(strikes, actuals[:, i], label=labels[i]+'_actual')
    plt.plot(strikes, predictions[:, i], label=labels[i]+'_predicted')
    plt.xlabel("Strike Price")
    plt.ylabel("Value")
    plt.title(labels[i])
    plt.legend()
plt.show()